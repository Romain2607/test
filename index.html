<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Vérin Hydraulique 3D Test</title>
  <style>
    body { margin: 0; background: #1a1a1a; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      color: white;
      font-family: sans-serif;
    }
    input[type=range] { width: 200px; }
    label { display: block; margin-top: 8px; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Course : <input type="range" id="slider" min="0" max="100" value="50"></label>
    <label>Rotation : <input type="range" id="rot" min="0" max="360" value="0"></label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lumières
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    // Paramètres du vérin
    let radiusCyl = 2;
    let radiusRod = 0.75;
    const maxCourse = 10;

    let group, cylFond, cylTige, piston, rod;

    function createVérin() {
      if (group) {
        scene.remove(group);
      }
      group = new THREE.Group();

      // longueur totale (on peut ajuster)
      const totalLength = maxCourse + 12;
      const halfLen = totalLength / 2;

      // Chambre fond (bleu transparent)
      const geoFond = new THREE.CylinderGeometry(radiusCyl, radiusCyl, halfLen, 32);
      const matFond = new THREE.MeshStandardMaterial({ color: 0x0077ff, transparent: true, opacity: 0.3 });
      cylFond = new THREE.Mesh(geoFond, matFond);
      cylFond.rotation.z = Math.PI/2;
      cylFond.position.x = - (halfLen/2);
      group.add(cylFond);

      // Chambre tige (vert transparent)
      const geoTige = new THREE.CylinderGeometry(radiusCyl, radiusCyl, halfLen, 32);
      const matTige = new THREE.MeshStandardMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 });
      cylTige = new THREE.Mesh(geoTige, matTige);
      cylTige.rotation.z = Math.PI/2;
      cylTige.position.x = + (halfLen/2);
      group.add(cylTige);

      // Piston (rouge)
      const geoPiston = new THREE.CylinderGeometry(radiusCyl, radiusCyl, 1, 32);
      const matPiston = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      piston = new THREE.Mesh(geoPiston, matPiston);
      piston.rotation.z = Math.PI/2;
      group.add(piston);

      // Tige (gris)
      const rodLen = 14;
      const geoRod = new THREE.CylinderGeometry(radiusRod, radiusRod, rodLen, 32);
      const matRod = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
      rod = new THREE.Mesh(geoRod, matRod);
      rod.rotation.z = Math.PI/2;
      group.add(rod);

      scene.add(group);
    }

    function update() {
      const sliderVal = document.getElementById("slider").value;
      const course = (sliderVal / 100) * maxCourse;

      // Position du piston
      const pistonX = course - (maxCourse / 2);
      piston.position.x = pistonX;

      // Position de la tige : fixée par rapport au piston
      // On positionne le centre de la tige plus loin que le piston
      const rodOffset = 6;
      rod.position.x = pistonX + rodOffset;

      // Rotation du groupe entier
      const rotVal = document.getElementById("rot").value;
      group.rotation.y = THREE.MathUtils.degToRad(rotVal);
    }

    // Initialisation
    createVérin();
    camera.position.set(0, 0, 30);
    update();

    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById("slider").addEventListener("input", update);
    document.getElementById("rot").addEventListener("input", update);

  </script>
</body>
</html>
